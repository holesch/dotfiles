set nocompatible " use Vim settings

" === General Vim configuration ===
set tabstop=4 " Set tab width to 4 spaces
set shiftwidth=4 " When indenting with '>', use 4 spaces width
set softtabstop=4 " Delete 4 spaces with backspace
set expandtab " On pressing tab, insert 4 spaces
set shiftround " Indent to a multiple of 4 spaces
set ignorecase " Ignore case when searching
set smartcase " Don't ignore case if there is an uppercase letter
set number " Display absolute line number
set showcmd " Display command while typing
set lazyredraw " The screen will not be redrawn while executing macros
set colorcolumn=80 " Highlight screen columns
set wildmode=longest:full,full " Complete commands till longest common string
set viminfo='1000,<500,s100,h,% " Set what to restore upon startup
set path+=** " Always search recursively
set listchars=tab:▸\ ,trail:·,nbsp:· " Set whitespace characters
set list " Show whitespace
set linebreak " Wrap only at whitespace characters
set spelllang=en_us " Set spell check region to American English
set completeopt-=preview " Hide the preview window
set autowrite " Save the file when jumping away
set guifont=Menlo\ Regular:h12 " Set font
set guioptions= " Hide scroll bar, menu, tabs, etc.
set splitright " Open new vertical splits to the right
set splitbelow " Open new horizontal splits below
set scrolloff=5 " Keep 5 lines above and below the cursor
set spell " Enable spell checking
set cursorline " Highlight current line

set statusline=
set statusline+=%1*\ %-2.n\ %*\  " Buffer number
set statusline+=%<%.99f\  " File name
set statusline+=%h%w%m%r\  " [help][Preview][+][RO]
set statusline+=%= " Switch to right side
set statusline+=%-14.{gutentags#statusline('[',']')}
set statusline+=%-14.y " File type
set statusline+=%-14.(%l:%c%V%)\  " Line:Column
set statusline+=%1*\ %P\ %* " Percentage through file

if has('mouse')
    set mouse=a " Enable mouse support
endif

if has('persistent_undo')
    set undodir=~/.cache/vim/undodir " Save undofiles to a central directory
    silent call system('mkdir -p ' . &undodir)
    set undofile " Keep undo history across sessions
endif

if has('autocmd')
    augroup vimrc_last_pos
        autocmd!
        " Jump to last known cursor position, when opening a file
        autocmd BufReadPost *
            \ if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit'
            \ |   execute "normal! g`\""
            \ | endif
    augroup END
endif

" Fix typos
cnoreabbrev Q q
cnoreabbrev Qa qa
cnoreabbrev Wq wq
cnoreabbrev W w

" === vimrc ===
if has('autocmd')
    augroup vimrc_vimrc
        autocmd!
        " Source the vimrc file after saving it
        autocmd BufWritePost vimrc source $MYVIMRC | call OverrideColors()
    augroup END
endif

" Open vimrc in a new tab
nnoremap <leader>v :tabedit $MYVIMRC<CR>:lcd <C-R>=fnameescape(expand('%:h')).'/'<CR><CR>

" === Appearance ===
" --- Color scheme ---
if has('autocmd')
    augroup vimrc_color
        autocmd!
        autocmd ColorScheme * call OverrideColors()
    augroup END
endif

if has('eval')
    function! OverrideColors()
        highlight! link Error Underlined
        highlight! link WildMenu Search
        call g:Base16hi("MatchParen", "", "", g:base16_cterm00, "", "", "")
        call g:Base16hi("SpellBad", "", "", "", g:base16_cterm00, "", "")
        call g:Base16hi("SpellLocal", "", "", "", g:base16_cterm00, "", "")
        call g:Base16hi("SpellCap", "", "", "", g:base16_cterm00, "", "")
        call g:Base16hi("SpellRare", "", "", "", g:base16_cterm00, "", "")
        highlight! link Sneak Search
        call g:Base16hi("User1", "", "", g:base16_cterm00, g:base16_cterm0D, "", "")
        highlight! link doxygenComment Comment
        highlight! link doxygenBrief Comment
        highlight! link doxygenSpecialOnelineDesc Comment
        highlight! link doxygenParam doxygenSpecial
        highlight! link doxygenParamName doxygenSpecial
    endfunction
endif

if has('eval')
     let base16colorspace=256  " Access colors present in 256 color space
endif
silent! colorscheme base16-monokai

" === General key mappings ===
if has('eval')
    " Strip trailing whitespace
    nnoremap <leader>$ :call <SID>Preserve("%s/\\s\\+$//e")<CR>

    " Reindent file
    nnoremap <leader>= :call <SID>Preserve("normal gg=G")<CR>

    function! s:Preserve(command)
        " Preparation: save last search, and cursor position.
        let _s=@/
        let l = line(".")
        let c = col(".")
        " Execute the command
        execute a:command
        " Clean up: restore previous search history, and cursor position
        let @/=_s
        call cursor(l, c)
    endfunction
endif

" Select the text that was last edited/pasted
nnoremap gV `[v`]

" Search and replace
nnoremap <leader>r :%s/\<<C-r><C-w>\>//gc<Left><Left><Left>
xnoremap <leader>r "vy:%s/\V<C-r>=escape('<C-r>v', '/\')<CR>//gc<Left><Left><Left>

" Copy to end of line
nnoremap Y y$

" System clipboard mappings
nnoremap <leader>y "+y
nnoremap <leader>Y "+y$
xnoremap <leader>y "+y
nnoremap <leader>p "+p
nnoremap <leader>P "+P
xnoremap <leader>p "+p
nnoremap <leader>gp "+gp
nnoremap <leader>gP "+gP

" disable ex mode
nnoremap Q <nop>

if has('eval')
    " l for "last" collides with l for "line", use N for "last" instead
    let g:targets_nl = 'nN'
endif

" inner line and a line
xnoremap <silent> il :<c-u>normal! g_v^<cr>
onoremap <silent> il :<c-u>normal! g_v^<cr>
xnoremap <silent> al :<C-u>normal! $v0<CR>
onoremap <silent> al :<c-u>normal! $v0<cr>
" a document
xnoremap <silent> ad :<c-u>normal! G$Vgg0<cr>
onoremap <silent> ad :<c-u>normal! GVgg<cr>
" inner function and a function
xmap af <Plug>TextobjCFunctionA
omap af <Plug>TextobjCFunctionA
xmap if <Plug>TextobjCFunctionI
omap if <Plug>TextobjCFunctionI

" Show syntax highlighting group under cursor
nnoremap <F10> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
\ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
\ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

" === Syntax settings ===
if has('eval')
    let g:is_posix = 1 " use POSIX syntax for .sh
endif

" === Auto completion ===
" --- Neocomplete ---
if has('lua')
    let g:neocomplete#enable_at_startup = 1 " Use neocomplete.
    let g:neocomplete#enable_smart_case = 1 " Use smartcase.
    inoremap <expr> <C-g> neocomplete#undo_completion()
    inoremap <expr> <C-l> neocomplete#complete_common_string()

    " close popup and add newline
    inoremap <silent> <CR> <C-r>=<SID>close_popup()<CR><CR>

    " <TAB> completion
    inoremap <silent><expr> <TAB>
          \ pumvisible() ? "\<C-n>" :
          \ <SID>is_white_space_before_cursor() ? "\<TAB>" :
          \ neocomplete#start_manual_complete()

    function! s:close_popup()
      return pumvisible() ? "\<C-y>" : ""
    endfunction

    function! s:is_white_space_before_cursor() abort
      let col = col('.') - 1
      return !col || getline('.')[col - 1]  =~ '\s'
    endfunction

    " Enable auto omni completion.
    if !exists('g:neocomplete#sources#omni#input_patterns')
      let g:neocomplete#sources#omni#input_patterns = {}
    endif
    let g:neocomplete#sources#omni#input_patterns.c =
    \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
    let g:neocomplete#sources#omni#input_patterns.cpp =
    \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
    if !exists('g:neocomplete#force_omni_input_patterns')
        let g:neocomplete#force_omni_input_patterns = {}
    endif
    let g:neocomplete#force_omni_input_patterns.python =
    \ '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'
endif

" --- Ultisnips ---
if has('python3')
    let g:UltiSnipsUsePythonVersion = 3
endif

" === Fuzzy finder ===
if has('eval')
    let g:ctrlp_extensions = ['tag']
    let g:ctrlp_show_hidden = 1
endif

" Use The Silver Searcher if installed
if executable('ag')
  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor

  " Use ag in CtrlP for listing files.
  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'

  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0
endif

" --- netrw ---
let g:netrw_altfile = 1 " CTRL-^ jumps to last edited file

" === cscope ===
if has("cscope")
    set cscopequickfix=s-,c-,d-,i-,t-,e- " Use quickfix window with cscope
    if has('patch-7.4.2033')
        set cscopequickfix+=a-
    endif

    set cscopetag " Use cscope with :tag and CTRL-]

    nnoremap <leader>cs :cscope find s <C-R>=expand("<cword>")<CR><CR>
    nnoremap <leader>cg :cscope find g <C-R>=expand("<cword>")<CR><CR>
    nnoremap <leader>cc :cscope find c <C-R>=expand("<cword>")<CR><CR>
    nnoremap <leader>ct :cscope find t <C-R>=expand("<cword>")<CR><CR>
    nnoremap <leader>ce :cscope find e <C-R>=expand("<cword>")<CR><CR>
    nnoremap <leader>cf :cscope find f <C-R>=expand("<cfile>")<CR><CR>
    nnoremap <leader>ci :cscope find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nnoremap <leader>cd :cscope find d <C-R>=expand("<cword>")<CR><CR>
    nnoremap <leader>ca :cscope find a <C-R>=expand("<cword>")<CR><CR>
    nnoremap <leader>c? :help cscope-find<CR>
endif

" --- bitbake ---
if has('eval')
    let g:bb_create_on_empty = 0
endif

" --- Sneak ---
if has('eval')
    let g:sneak#label = 1
endif
