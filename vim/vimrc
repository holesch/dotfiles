set nocompatible " use Vim settings

" === General Vim configuration ===
set tabstop=4 " Set tab width to 4 spaces
set shiftwidth=4 " When indenting with '>', use 4 spaces width
set softtabstop=4 " Delete 4 spaces with backspace
set expandtab " On pressing tab, insert 4 spaces
set ignorecase " Ignore case when searching
set smartcase " Don't ignore case if there is an uppercase letter
set relativenumber " Display relative line numbers
set number " Display absolute line number on current line
set showcmd " Display command while typing
set lazyredraw " The screen will not be redrawn while executing macros
set colorcolumn=50,72,80 " Highlight screen columns
set wildmode=longest:full,full " Complete commands till longest common string
set viminfo='1000,<500,s100,h,% " Set what to restore upon startup
set clipboard=unnamed " Use system clipboard
set path+=** " Always search recursively
set listchars=tab:▸\ ,eol:¬ " Set whitespace characters
set list " Show whitespace
set linebreak " Wrap only at whitespace characters
set spelllang=en_us " Set spell check region to American English
set noshowmode " Hide the current mode in the last line
set completeopt-=preview " Hide the preview window
set autowrite " Save the file when jumping away
set cursorline " Highlight current line
set mouse=a " Enable mouse support
set guifont=Menlo\ Regular:h12 " Set font
set guioptions= " Hide scroll bar, menu, tabs, etc.

" === vimrc ===
augroup vimrc_vimrc
    autocmd!
    " Source the vimrc file after saving it
    autocmd BufWritePost vimrc source $MYVIMRC | AirlineRefresh
augroup END

" Open vimrc in a new tab
nnoremap <leader>v :tabedit $MYVIMRC<CR>:lcd <C-R>=fnameescape(expand('%:h')).'/'<CR><CR>

" === Aesthetics ===
" --- Color scheme ---
let base16colorspace=256  " Access colors present in 256 color space
colorscheme base16-materia

" --- Airline ---
let g:airline_theme = 'tomorrow'
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#tab_nr_type = 1
let g:airline#extensions#tabline#show_tab_type = 0
let g:airline#extensions#tabline#show_close_button = 0
let g:airline#extensions#tabline#show_splits = 0
let g:airline#extensions#tabline#formatter = 'cwd'
let g:airline#extensions#tabline#show_buffers = 0

" === General key mappings ===
" Strip trailing whitespace
nnoremap <leader>$ :call Preserve("%s/\\s\\+$//e")<CR>

" Reindent file
nnoremap <leader>= :call Preserve("normal gg=G")<CR>

function! Preserve(command)
    " Preparation: save last search, and cursor position.
    let _s=@/
    let l = line(".")
    let c = col(".")
    " Execute the command
    execute a:command
    " Clean up: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction

" Select the text that was last edited/pasted
nnoremap gV `[v`]

" Search and replace word under cursor
nnoremap <leader>r :%s/\<<C-r><C-w>\>//gc<Left><Left><Left>

" Build or test
nnoremap <leader>bb :Make<CR>
nnoremap <leader>bt :Make test<CR>

" Toggle the undo graph
if has('python3')
    let g:gundo_prefer_python3 = 1
endif
nnoremap <F5> :GundoToggle<CR>

" === Auto completion ===
" --- Neocomplete ---
if has('lua')
    let g:neocomplete#enable_at_startup = 1 " Use neocomplete.
    let g:neocomplete#enable_smart_case = 1 " Use smartcase.
    inoremap <expr> <C-g> neocomplete#undo_completion()
    inoremap <expr> <C-l> neocomplete#complete_common_string()

    " close popup and add newline
    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>

    " <TAB> completion
    inoremap <silent><expr> <TAB>
          \ pumvisible() ? "\<C-n>" :
          \ <SID>is_white_space_before_cursor() ? "\<TAB>" :
          \ neocomplete#start_manual_complete()

    " close popup and delete char
    inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"

    function! s:my_cr_function()
      return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
    endfunction

    function! s:is_white_space_before_cursor() abort
      let col = col('.') - 1
      return !col || getline('.')[col - 1]  =~ '\s'
    endfunction

    " Enable auto omni completion.
    if !exists('g:neocomplete#sources#omni#input_patterns')
      let g:neocomplete#sources#omni#input_patterns = {}
    endif
    let g:neocomplete#sources#omni#input_patterns.c =
    \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
    let g:neocomplete#sources#omni#input_patterns.cpp =
    \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
endif

" --- Ultisnips ---
if has('python3')
    let g:UltiSnipsUsePythonVersion = 3
endif

" === Syntax checker ===
" --- Syntastic ---
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_error_symbol = "✗"
let g:syntastic_warning_symbol = "⚠"
let g:syntastic_style_error_symbol = "S✗"
let g:syntastic_style_warning_symbol = "S⚠"
let g:syntastic_enable_balloons = 0
let g:syntastic_loc_list_height = 5
let g:syntastic_xml_checkers = []

" " --- ALE ---
" let g:ale_list_window_size = 5
" let g:ale_open_list = 1
" let g:ale_set_balloons = 0
" let g:ale_sign_error = "✗"
" let g:ale_sign_warning = "⚠"
" let g:ale_sign_info = "ℹ"
" let g:ale_sign_style_error = "S✗"
" let g:ale_sign_style_warning = "S⚠"
" let g:ale_sign_column_always = 1

" === cscope ===
if has("cscope")
    set cscopequickfix=s-,c-,d-,i-,t-,e-,a- " Use quickfix window with cscope
    set cscopetag " Use cscope with :tag and CTRL-]
    " add any database in current directory
    if filereadable("cscope.out")
        cs add cscope.out
        " else add database pointed to by environment
    elseif $CSCOPE_DB != ""
        cs add $CSCOPE_DB
    endif
    set cscopeverbose " Print message when adding a database

    nnoremap <C-_>s :cs find s <C-R>=expand("<cword>")<CR><CR>
    nnoremap <C-_>g :cs find g <C-R>=expand("<cword>")<CR><CR>
    nnoremap <C-_>c :cs find c <C-R>=expand("<cword>")<CR><CR>
    nnoremap <C-_>t :cs find t <C-R>=expand("<cword>")<CR><CR>
    nnoremap <C-_>e :cs find e <C-R>=expand("<cword>")<CR><CR>
    nnoremap <C-_>f :cs find f <C-R>=expand("<cfile>")<CR><CR>
    nnoremap <C-_>i :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nnoremap <C-_>d :cs find d <C-R>=expand("<cword>")<CR><CR>
    nnoremap <C-_>a :cs find a <C-R>=expand("<cword>")<CR><CR>
    nnoremap <C-_>? :help cscope-find<CR>
endif

